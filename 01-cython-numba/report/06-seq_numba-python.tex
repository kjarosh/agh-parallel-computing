\section{Sekwencyjna Numba i Python}
Przeprowadziliśmy testy również dla przypadku sekwencyjnego, tzn. wykonywanego w jednym wątku.
Kod Pythona został skompilowany jednak do kodu maszynowego, zatem interpreter nie brał bezpośredniego udziału w obliczeniach.

Oprócz tego porównaliśmy obliczenia sekwencyjne w czystym Pythonie jak również z wykorzystaniem pakietu multiprocessing,
który pozwala na obejście GIL (Global Interpreter Lock).

\subsection{Przybliżanie liczby pi}
Wykresy przeprowadzone dla sekwencyjnej Numby i Pythona zgadzają się z oczekiwanymi przez nas wynikami: wraz ze wzrostem problemu czas wykonania rośnie liniowo.
Możemy jednak zauważyć że zastosowanie biblioteki Multiprocessing powoduje przyspieszenie obliczeń.

\begin{figure*}
        \centering
        \input{tikz/sizes-numba-seq.tikz}
        \caption{Czas sekwencyjnego wykonania algorytmu w Numbie w zależności od rozmiaru problemu}
        \label{fig:numba-seq-sizes}
    \end{figure*}

    \begin{figure*}
        \centering
        \begin{minipage}[b]{.45\textwidth}
            \centering
            \input{tikz/speedup-python.tikz}
            \caption{Przyspieszenie liczenia liczby $\pi$ w czystym Pythonie}
            \label{fig:python-speedup}
        \end{minipage}
        \hfill
        \begin{minipage}[b]{.45\textwidth}
            \centering
            \input{tikz/threads-python.tikz}
            \caption{Czas wykonania algorytmu w czystym Pythonie w zależności od liczby wątków}
            \label{fig:python-threads}
        \end{minipage}
    \end{figure*}

    \begin{figure*}
        \centering
        \input{tikz/sizes-python.tikz}
        \caption{Czas wykonania algorytmu w czystym Pythonie w zależności od rozmiaru problemu}
        \label{fig:python-sizes}
    \end{figure*}


    \begin{figure*}
        \centering
        \begin{minipage}[b]{.45\textwidth}
            \centering
            \input{tikz/speedup-all.tikz}
            \caption{Przyspieszenie liczenia liczby $\pi$}
            \label{fig:all-speedup}
        \end{minipage}
        \hfill
        \begin{minipage}[b]{.45\textwidth}
            \centering
            \input{tikz/threads-all.tikz}
            \caption{Czas wykonania algorytmu w zależności od liczby wątków}
            \label{fig:all-threads}
        \end{minipage}
    \end{figure*}

    \begin{figure*}
        \centering
        \input{tikz/sizes-seq.tikz}
        \caption{Czas wykonania algorytmu w zależności od rozmiaru problemu}
        \label{fig:all-sizes-seq}
    \end{figure*}

    \begin{figure*}
        \centering
        \input{tikz/sizes-parallel.tikz}
        \caption{Czas wykonania algorytmu w zależności od rozmiaru problemu}
        \label{fig:all-sizes-parallel}
    \end{figure*}

Wykres ~\ref{fig:numba-threads} przedstawia zależność czasu rozwiązania problemu od ilości wykorzystywanych
wątków. Możęmy zaobserwować, że wraz ze zwiększaniem liczby wątków istotnie maleje czas
wykonania programu. Program skaluje się bardzo dobrze dla 2, 3 i 4 wątków natomiast
dokładanie kolejnych tj. 5, 6, 7, 8 nie daje już aż tak dobrego rezultatu. Widać to dokładnie
na wykresie ~\ref{fig:numba-speedup} gdzie począwszy od 5 wątków realne przyspieszenie
programu zdecydowanie odbiega od teoretycznego.

%Ostatni wykres ~\ref{fig:numba-parallel-sizes}) przedstawia czas równoległego wykonania
%programu w Numbie w zależności od rozmiaru problemu. Wyniki są zgodne z oczekiwanymi.
%Dla problemu o małym rozmiarze (liczba losowanych punktów = 100000) algorytm sekwencyjny
%jest szybszy od algorytmu równoległego, natomiast już od rozmiaru równego
%200000 sytuacja się odwraca. Dla obu opcji zostały również wykonane pomiary z opcją
%fastmath, która minimalnie przyspiesza działanie programów.



%\subsection{Mnożenie wektorów}
