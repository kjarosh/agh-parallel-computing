\section{Sekwencyjna Numba i Python (Wiktor Sus)}
Przeprowadziliśmy testy również dla przypadku sekwencyjnego, tzn.\ wykonywanego w jednym wątku.
Kod Pythona został skompilowany jednak do kodu maszynowego, zatem interpreter nie brał bezpośredniego udziału w obliczeniach.

Oprócz tego porównaliśmy obliczenia sekwencyjne w czystym Pythonie jak również z wykorzystaniem pakietu multiprocessing,
który pozwala na obejście GIL (Global Interpreter Lock).

\subsection{Przybliżanie liczby pi}
Wykresy testów przeprowadzonych dla sekwencyjnej Numby i Pythona pokrywają się z oczekiwanymi przez nas wynikami: wraz ze wzrostem problemu czas wykonania rośnie liniowo.
Możemy jednak zauważyć że zastosowanie biblioteki Multiprocessing powoduje przyspieszenie obliczeń.
Na wykresie \ref{fig:numba-seq-sizes} przedstawione jest porównanie czasów sekwencyjnego wykonania programu w zależności od jego rozmiaru dla Numby w wariancie podstawowym oraz z użyciem opcji FastMath.
Możemy zauważyć niewielkie przyspieszenie w drugim przypadku, które osiągane jest kosztem dokładności obliczeń.
Na wykresie \ref{fig:python-speedup} widzimy przyspieszenie wykonywania obliczeń w zależności od ilości wątków wraz z odpowiadającym wykresem czasu wykonania \ref{fig:python-threads}.
Możemy zauważyć że zastosowanie wielu procesów pozwala na uzyskanie znacznego przyspieszenia, jednak powyżej pewnego pułapu jest ono coraz mniejsze.
Ostatnim wykonanym testem było porównanie czasu wykonania dla samego Pythona oraz wariantu z wykorzystaniem biblioteki MultiProcessing.
Wyniki zebrane zostały na wykresie \ref{fig:python-sizes}, gdzie możemy zauważyć istotną przewagę wydajności Pythona MultiProcessing.


\begin{figure*}
    \centering
    \input{tikz/sizes-numba-seq.tikz}
    \caption{Czas sekwencyjnego wykonania algorytmu w Numbie w zależności od rozmiaru problemu}
    \label{fig:numba-seq-sizes}
\end{figure*}

\begin{figure*}
    \centering
    \begin{minipage}[b]{.45\textwidth}
        \centering
        \input{tikz/speedup-python.tikz}
        \caption{Przyspieszenie liczenia liczby $\pi$ w czystym Pythonie}
        \label{fig:python-speedup}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{.45\textwidth}
        \centering
        \input{tikz/threads-python.tikz}
        \caption{Czas wykonania algorytmu w czystym Pythonie w zależności od liczby wątków}
        \label{fig:python-threads}
    \end{minipage}
\end{figure*}

\begin{figure*}
    \centering
    \input{tikz/sizes-python.tikz}
    \caption{Czas wykonania algorytmu w czystym Pythonie i Pythonie MP w zależności od rozmiaru problemu}
    \label{fig:python-sizes}
\end{figure*}
