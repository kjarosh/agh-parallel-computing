\section{Sekwencyjna Numba i Python}
Przeprowadziliśmy testy również dla przypadku sekwencyjnego, tzn.\ wykonywanego w jednym wątku.
Kod Pythona został skompilowany jednak do kodu maszynowego, zatem interpreter nie brał bezpośredniego udziału w obliczeniach.

Oprócz tego porównaliśmy obliczenia sekwencyjne w czystym Pythonie jak również z wykorzystaniem pakietu multiprocessing,
który pozwala na obejście GIL (Global Interpreter Lock).

\subsection{Przybliżanie liczby pi}
Wykresy przeprowadzone dla sekwencyjnej Numby i Pythona zgadzają się z oczekiwanymi przez nas wynikami: wraz ze wzrostem problemu czas wykonania rośnie liniowo.
Możemy jednak zauważyć że zastosowanie biblioteki Multiprocessing powoduje przyspieszenie obliczeń.

\begin{figure*}
    \centering
    \input{tikz/sizes-numba-seq.tikz}
    \caption{Czas sekwencyjnego wykonania algorytmu w Numbie w zależności od rozmiaru problemu}
    \label{fig:numba-seq-sizes}
\end{figure*}

\begin{figure*}
    \centering
    \begin{minipage}[b]{.45\textwidth}
        \centering
        \input{tikz/speedup-python.tikz}
        \caption{Przyspieszenie liczenia liczby $\pi$ w czystym Pythonie}
        \label{fig:python-speedup}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{.45\textwidth}
        \centering
        \input{tikz/threads-python.tikz}
        \caption{Czas wykonania algorytmu w czystym Pythonie w zależności od liczby wątków}
        \label{fig:python-threads}
    \end{minipage}
\end{figure*}

\begin{figure*}
    \centering
    \input{tikz/sizes-python.tikz}
    \caption{Czas wykonania algorytmu w czystym Pythonie w zależności od rozmiaru problemu}
    \label{fig:python-sizes}
\end{figure*}
